# F1.2 - Image Preprocessing

## Overview

| Attribute | Value |
|-----------|-------|
| Feature ID | F1.2 |
| Phase | 1 (MVP) |
| Priority | P0 |
| Status | Planned |
| Module | `chronoscribe.core.preprocessor` |

## Description

Prepare scanned images for optimal OCR accuracy. The preprocessor enhances image quality, corrects orientation issues, and normalizes output for consistent processing across different scanners and cameras.

## Requirements

### Functional Requirements

1. **FR1.2.1** - Auto-rotate images based on EXIF orientation data
2. **FR1.2.2** - Detect and correct skew (deskew) up to 15 degrees
3. **FR1.2.3** - Enhance contrast for faded or low-contrast documents
4. **FR1.2.4** - Detect and crop document borders
5. **FR1.2.5** - Reduce noise while preserving text edges
6. **FR1.2.6** - Normalize resolution to 300 DPI
7. **FR1.2.7** - Convert to PNG output format

### Non-Functional Requirements

1. **NFR1.2.1** - Process a single page in < 5 seconds
2. **NFR1.2.2** - Preserve text legibility (no over-processing)
3. **NFR1.2.3** - Memory usage < 500MB per image

## Technical Design

### Dependencies

```python
pillow>=10.0.0           # Image loading and basic operations
opencv-python>=4.8.0     # Advanced image processing
numpy>=1.24.0            # Array operations (opencv dependency)
```

### Module Structure

```
src/chronoscribe/core/
├── preprocessor.py      # Main preprocessing pipeline
└── image_utils.py       # Helper functions
```

### Class Design

```python
from dataclasses import dataclass
from pathlib import Path
from PIL import Image
import cv2
import numpy as np

@dataclass
class PreprocessingResult:
    """Result of image preprocessing."""
    original_path: Path
    normalized_path: Path
    original_size: tuple[int, int]
    normalized_size: tuple[int, int]
    original_dpi: int | None
    normalized_dpi: int
    rotation_applied: float  # Degrees
    skew_corrected: float    # Degrees
    contrast_enhanced: bool
    borders_cropped: bool
    processing_time_ms: int

@dataclass
class PreprocessingOptions:
    """Configuration for preprocessing operations."""
    target_dpi: int = 300
    auto_rotate: bool = True
    deskew: bool = True
    deskew_max_angle: float = 15.0
    enhance_contrast: bool = True
    auto_crop: bool = True
    denoise: bool = True
    output_format: str = "png"
    jpeg_quality: int = 95

class ImagePreprocessor:
    """
    Prepares images for optimal OCR accuracy.

    Applies a series of transformations to enhance text
    legibility and normalize image properties.
    """

    def __init__(self, options: PreprocessingOptions | None = None):
        self.options = options or PreprocessingOptions()

    def process(self, input_path: Path, output_path: Path) -> PreprocessingResult:
        """
        Process an image through the full preprocessing pipeline.

        Args:
            input_path: Path to the original image
            output_path: Path to save the normalized image

        Returns:
            PreprocessingResult with details of operations applied
        """
        ...

    def _load_image(self, path: Path) -> tuple[np.ndarray, dict]:
        """Load image and extract metadata."""
        ...

    def _auto_rotate(self, image: np.ndarray, exif: dict) -> tuple[np.ndarray, float]:
        """Rotate based on EXIF orientation."""
        ...

    def _detect_skew(self, image: np.ndarray) -> float:
        """Detect document skew angle using Hough transform."""
        ...

    def _deskew(self, image: np.ndarray, angle: float) -> np.ndarray:
        """Rotate image to correct skew."""
        ...

    def _enhance_contrast(self, image: np.ndarray) -> np.ndarray:
        """Apply CLAHE for adaptive contrast enhancement."""
        ...

    def _detect_borders(self, image: np.ndarray) -> tuple[int, int, int, int]:
        """Detect document borders for cropping."""
        ...

    def _crop_borders(self, image: np.ndarray, borders: tuple) -> np.ndarray:
        """Crop image to detected borders."""
        ...

    def _denoise(self, image: np.ndarray) -> np.ndarray:
        """Apply noise reduction while preserving edges."""
        ...

    def _normalize_dpi(self, image: np.ndarray, current_dpi: int) -> np.ndarray:
        """Scale image to target DPI."""
        ...
```

### Processing Pipeline

```
Input Image
     │
     ▼
Load Image + Extract EXIF
     │
     ▼
Auto-Rotate (EXIF) ─────────────────────┐
     │                                  │
     ▼                                  │
Convert to Grayscale (for analysis)     │
     │                                  │
     ▼                                  │
Detect Skew Angle                       │
     │                                  │
     ▼                                  │ (Apply to
Deskew (if angle > threshold)           │  original
     │                                  │  color image)
     ▼                                  │
Detect Borders                          │
     │                                  │
     ▼                                  │
Crop to Borders ────────────────────────┘
     │
     ▼
Enhance Contrast (CLAHE)
     │
     ▼
Denoise (Bilateral Filter)
     │
     ▼
Normalize DPI (300)
     │
     ▼
Save as PNG
```

### Algorithm Details

#### Skew Detection (Hough Transform)

```python
def _detect_skew(self, image: np.ndarray) -> float:
    """
    Detect document skew using probabilistic Hough line transform.

    Returns angle in degrees (positive = clockwise rotation needed)
    """
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)

    lines = cv2.HoughLinesP(
        edges,
        rho=1,
        theta=np.pi / 180,
        threshold=100,
        minLineLength=100,
        maxLineGap=10
    )

    if lines is None:
        return 0.0

    angles = []
    for line in lines:
        x1, y1, x2, y2 = line[0]
        angle = np.degrees(np.arctan2(y2 - y1, x2 - x1))
        # Only consider near-horizontal lines
        if abs(angle) < self.options.deskew_max_angle:
            angles.append(angle)

    if not angles:
        return 0.0

    return np.median(angles)
```

#### Contrast Enhancement (CLAHE)

```python
def _enhance_contrast(self, image: np.ndarray) -> np.ndarray:
    """
    Apply Contrast Limited Adaptive Histogram Equalization.

    CLAHE prevents over-amplification of noise while
    improving local contrast.
    """
    if len(image.shape) == 3:
        # Convert to LAB, enhance L channel only
        lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
        l, a, b = cv2.split(lab)

        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        l = clahe.apply(l)

        lab = cv2.merge([l, a, b])
        return cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)
    else:
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        return clahe.apply(image)
```

#### Border Detection

```python
def _detect_borders(self, image: np.ndarray) -> tuple[int, int, int, int]:
    """
    Detect document borders using contour analysis.

    Returns (x, y, width, height) of detected document region.
    """
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # Edge detection
    edges = cv2.Canny(blurred, 50, 150)

    # Dilate to connect edges
    kernel = np.ones((5, 5), np.uint8)
    dilated = cv2.dilate(edges, kernel, iterations=2)

    # Find contours
    contours, _ = cv2.findContours(
        dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    if not contours:
        return (0, 0, image.shape[1], image.shape[0])

    # Find largest contour (assumed to be document)
    largest = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(largest)

    # Add small padding
    padding = 10
    x = max(0, x - padding)
    y = max(0, y - padding)
    w = min(image.shape[1] - x, w + 2 * padding)
    h = min(image.shape[0] - y, h + 2 * padding)

    return (x, y, w, h)
```

### Configuration

```yaml
preprocessing:
  target_dpi: 300
  auto_rotate: true
  deskew: true
  deskew_max_angle: 15.0
  enhance_contrast: true
  auto_crop: true
  denoise: true
  output_format: png
  jpeg_quality: 95
```

## API

### Public Methods

```python
class ImagePreprocessor:
    def process(
        self,
        input_path: Path,
        output_path: Path,
    ) -> PreprocessingResult:
        """
        Process an image through the full preprocessing pipeline.

        Args:
            input_path: Path to the original image file
            output_path: Path where normalized image will be saved

        Returns:
            PreprocessingResult containing processing details

        Raises:
            FileNotFoundError: If input file doesn't exist
            UnsupportedFormatError: If image format isn't supported
            PreprocessingError: If processing fails
        """

    def process_pdf(
        self,
        input_path: Path,
        output_dir: Path,
    ) -> list[PreprocessingResult]:
        """
        Process a multi-page PDF, extracting and preprocessing each page.

        Args:
            input_path: Path to the PDF file
            output_dir: Directory to save normalized page images

        Returns:
            List of PreprocessingResult, one per page
        """
```

## Testing Strategy

### Unit Tests

```python
# tests/unit/core/test_preprocessor.py

def test_detect_skew_returns_zero_for_straight_document():
    preprocessor = ImagePreprocessor()
    straight_image = create_test_image(skew=0)
    angle = preprocessor._detect_skew(straight_image)
    assert abs(angle) < 0.5

def test_detect_skew_detects_clockwise_skew():
    preprocessor = ImagePreprocessor()
    skewed_image = create_test_image(skew=5)
    angle = preprocessor._detect_skew(skewed_image)
    assert 4 < angle < 6

def test_enhance_contrast_increases_dynamic_range():
    preprocessor = ImagePreprocessor()
    low_contrast = create_low_contrast_image()
    enhanced = preprocessor._enhance_contrast(low_contrast)

    original_range = low_contrast.max() - low_contrast.min()
    enhanced_range = enhanced.max() - enhanced.min()

    assert enhanced_range > original_range
```

### Integration Tests

```python
# tests/integration/test_preprocessor_integration.py

def test_full_pipeline_produces_valid_output(tmp_path, sample_scan):
    preprocessor = ImagePreprocessor()
    output_path = tmp_path / "normalized.png"

    result = preprocessor.process(sample_scan, output_path)

    assert output_path.exists()
    assert result.normalized_dpi == 300

    # Verify output is valid image
    img = Image.open(output_path)
    assert img.format == "PNG"
```

## Dependencies

### Upstream
- File watcher (provides input files)
- Configuration (for options)

### Downstream
- Transcription engine (receives normalized images)
- Folder generator (stores normalized images)

## Implementation Notes

1. **EXIF Handling**: Use Pillow for EXIF extraction, handle missing data gracefully
2. **Memory Management**: Process large images in chunks if needed
3. **Color Preservation**: Keep original color for archive, use grayscale only for analysis
4. **PDF Handling**: Use PyMuPDF (fitz) for extraction, process each page separately
5. **HEIC Support**: May require additional libraries on non-macOS systems

## Acceptance Criteria

- [ ] Auto-rotate based on EXIF data works correctly
- [ ] Deskew corrects tilted scans up to 15 degrees
- [ ] Contrast enhancement improves faded document legibility
- [ ] Border detection and cropping removes scanner margins
- [ ] Noise reduction preserves text edges
- [ ] Output is normalized to 300 DPI PNG
- [ ] Processing completes in < 5 seconds per page
- [ ] PDF pages are extracted and processed individually
