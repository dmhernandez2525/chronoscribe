# F1.1 - Watch Folder Monitoring

## Overview

| Attribute | Value |
|-----------|-------|
| Feature ID | F1.1 |
| Phase | 1 (MVP) |
| Priority | P0 |
| Status | Planned |
| Module | `chronoscribe.core.watcher` |

## Description

Monitor the `~/ChronoScribe/inbox/` directory for new files and automatically queue them for processing. The watcher must handle edge cases like incomplete file uploads, temporary files, and unsupported formats.

## Requirements

### Functional Requirements

1. **FR1.1.1** - Detect new files within 5 seconds of creation
2. **FR1.1.2** - Debounce file events to wait for write completion
3. **FR1.1.3** - Filter by supported file extensions
4. **FR1.1.4** - Ignore files matching ignore patterns
5. **FR1.1.5** - Queue files for processing pipeline
6. **FR1.1.6** - Handle watcher restart gracefully (process existing files)

### Non-Functional Requirements

1. **NFR1.1.1** - Minimal CPU usage when idle (< 1%)
2. **NFR1.1.2** - Memory usage < 50MB for watcher process
3. **NFR1.1.3** - Reliable detection (no missed files)

## Technical Design

### Dependencies

```python
watchdog>=3.0.0  # Cross-platform file system monitoring
```

### Module Structure

```
src/chronoscribe/core/
├── watcher.py          # Main watcher implementation
└── queue.py            # Processing queue management
```

### Class Design

```python
from dataclasses import dataclass
from pathlib import Path
from datetime import datetime
from enum import Enum
from typing import Callable
import asyncio

class FileStatus(Enum):
    DETECTED = "detected"
    QUEUED = "queued"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class WatchedFile:
    path: Path
    detected_at: datetime
    size: int
    status: FileStatus = FileStatus.DETECTED
    last_modified: datetime | None = None

class FileWatcher:
    """
    Monitors inbox directory for new files.

    Uses watchdog for cross-platform file system events with
    debouncing to handle incomplete file uploads.
    """

    def __init__(
        self,
        inbox_path: Path,
        extensions: list[str],
        ignore_patterns: list[str],
        debounce_seconds: float = 2.0,
        on_file_ready: Callable[[Path], None] | None = None,
    ):
        self.inbox_path = inbox_path
        self.extensions = {ext.lower() for ext in extensions}
        self.ignore_patterns = ignore_patterns
        self.debounce_seconds = debounce_seconds
        self.on_file_ready = on_file_ready
        self._pending: dict[Path, WatchedFile] = {}
        self._observer: Observer | None = None
        self._running = False

    async def start(self) -> None:
        """Start watching the inbox directory."""
        ...

    async def stop(self) -> None:
        """Stop the watcher gracefully."""
        ...

    def _is_supported(self, path: Path) -> bool:
        """Check if file extension is supported."""
        return path.suffix.lower() in self.extensions

    def _is_ignored(self, path: Path) -> bool:
        """Check if file matches ignore patterns."""
        ...

    async def _debounce_file(self, path: Path) -> None:
        """Wait for file to stabilize before processing."""
        ...

    def _scan_existing(self) -> list[Path]:
        """Scan inbox for existing files on startup."""
        ...
```

### Event Handling Flow

```
File Created Event
        │
        ▼
Check Extension ──── Unsupported ──▶ Ignore
        │
    Supported
        │
        ▼
Check Ignore Patterns ──── Matches ──▶ Ignore
        │
    Not Ignored
        │
        ▼
Add to Pending Queue
        │
        ▼
Start Debounce Timer (2s)
        │
        ▼
File Modified? ──── Yes ──▶ Reset Timer
        │
        No (timer expires)
        │
        ▼
Verify File Size Stable
        │
        ▼
Queue for Processing
        │
        ▼
Trigger on_file_ready callback
```

### Configuration

```yaml
watcher:
  debounce_seconds: 2.0
  extensions:
    - .png
    - .jpg
    - .jpeg
    - .tiff
    - .tif
    - .bmp
    - .webp
    - .heic
    - .pdf
  ignore_patterns:
    - ".*"      # Hidden files
    - "_*"      # Temp files with underscore prefix
    - "*.tmp"   # Temporary files
    - "*.part"  # Partial downloads
```

### Error Handling

| Scenario | Handling |
|----------|----------|
| File deleted before processing | Log warning, remove from queue |
| Permission denied | Log error, skip file, notify user |
| Inbox directory missing | Create it, log info |
| Observer crash | Auto-restart with exponential backoff |

## API

### Public Methods

```python
class FileWatcher:
    async def start(self) -> None:
        """
        Start watching the inbox directory.

        Scans existing files first, then begins monitoring
        for new files.

        Raises:
            WatcherError: If the inbox directory is invalid
        """

    async def stop(self) -> None:
        """
        Stop the watcher gracefully.

        Waits for any pending debounce timers to complete.
        """

    def get_pending_count(self) -> int:
        """Return count of files waiting to be processed."""

    def get_queue_status(self) -> list[WatchedFile]:
        """Return status of all tracked files."""
```

### Events/Callbacks

```python
# Callback signature for file ready event
Callable[[Path], None]

# Example usage
def handle_file_ready(path: Path) -> None:
    logger.info("File ready for processing", extra={"path": str(path)})
    pipeline.queue(path)

watcher = FileWatcher(
    inbox_path=Path("~/ChronoScribe/inbox").expanduser(),
    extensions=[".png", ".jpg", ".pdf"],
    ignore_patterns=[".*", "*.tmp"],
    on_file_ready=handle_file_ready,
)
```

## Testing Strategy

### Unit Tests

```python
# tests/unit/core/test_watcher.py

def test_is_supported_returns_true_for_valid_extensions():
    watcher = FileWatcher(...)
    assert watcher._is_supported(Path("test.png")) is True
    assert watcher._is_supported(Path("test.PNG")) is True  # Case insensitive

def test_is_supported_returns_false_for_invalid_extensions():
    watcher = FileWatcher(...)
    assert watcher._is_supported(Path("test.txt")) is False

def test_is_ignored_matches_hidden_files():
    watcher = FileWatcher(ignore_patterns=[".*"])
    assert watcher._is_ignored(Path(".hidden.png")) is True

def test_is_ignored_does_not_match_normal_files():
    watcher = FileWatcher(ignore_patterns=[".*"])
    assert watcher._is_ignored(Path("normal.png")) is False
```

### Integration Tests

```python
# tests/integration/test_watcher_integration.py

@pytest.mark.asyncio
async def test_watcher_detects_new_file(tmp_path):
    inbox = tmp_path / "inbox"
    inbox.mkdir()

    detected_files = []
    watcher = FileWatcher(
        inbox_path=inbox,
        extensions=[".png"],
        ignore_patterns=[],
        debounce_seconds=0.1,  # Short for testing
        on_file_ready=detected_files.append,
    )

    await watcher.start()

    # Create a test file
    test_file = inbox / "test.png"
    test_file.write_bytes(b"fake png data")

    # Wait for debounce
    await asyncio.sleep(0.3)

    assert len(detected_files) == 1
    assert detected_files[0] == test_file

    await watcher.stop()
```

## Dependencies

### Upstream
- Configuration system (for settings)
- Logging (for event logging)

### Downstream
- Processing queue (receives ready files)
- Pipeline (processes queued files)

## Implementation Notes

1. Use `watchdog.observers.Observer` for cross-platform support
2. Implement debouncing with `asyncio.create_task` and cancellation
3. On startup, scan inbox for existing files to process
4. Log all file events at DEBUG level for troubleshooting
5. Handle HEIC files specially (may need conversion on non-macOS)

## Acceptance Criteria

- [ ] Files dropped in inbox are detected within 5 seconds
- [ ] Debouncing prevents processing of incomplete uploads
- [ ] All supported formats are accepted (PNG, JPG, JPEG, TIFF, BMP, WEBP, HEIC, PDF)
- [ ] Hidden files (.*) are ignored
- [ ] Temporary files (*.tmp, _*) are ignored
- [ ] Existing files in inbox are processed on startup
- [ ] Watcher recovers gracefully from errors
- [ ] CPU usage < 1% when idle
