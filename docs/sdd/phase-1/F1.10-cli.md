# F1.10 - CLI Interface

## Overview

| Attribute | Value |
|-----------|-------|
| Feature ID | F1.10 |
| Phase | 1 (MVP) |
| Priority | P0 |
| Status | Planned |
| Module | `chronoscribe.cli` |

## Description

Command-line interface using Click and Rich for formatted output. Provides commands for all core operations: watching, processing, searching, clarifying, and viewing statistics.

## Requirements

### Functional Requirements

1. **FR1.10.1** - `chronoscribe init` - Initialize ChronoScribe
2. **FR1.10.2** - `chronoscribe watch` - Start file watcher
3. **FR1.10.3** - `chronoscribe process` - Process single file
4. **FR1.10.4** - `chronoscribe search` - Full-text search
5. **FR1.10.5** - `chronoscribe clarify` - Review clarifications
6. **FR1.10.6** - `chronoscribe timeline` - View timeline
7. **FR1.10.7** - `chronoscribe stats` - Show statistics
8. **FR1.10.8** - `chronoscribe config` - Manage configuration

### Non-Functional Requirements

1. **NFR1.10.1** - All commands have --help documentation
2. **NFR1.10.2** - Rich formatting for readable output
3. **NFR1.10.3** - Progress bars for long operations
4. **NFR1.10.4** - Clear error messages
5. **NFR1.10.5** - Exit codes follow conventions

## Technical Design

### Dependencies

```python
click>=8.1.0         # CLI framework
rich>=13.0.0         # Terminal formatting
```

### Module Structure

```
src/chronoscribe/
├── cli.py           # Main CLI entry point
├── commands/
│   ├── __init__.py
│   ├── init.py
│   ├── watch.py
│   ├── process.py
│   ├── search.py
│   ├── clarify.py
│   ├── timeline.py
│   └── stats.py
└── __main__.py      # Entry point
```

### Main CLI

```python
# src/chronoscribe/cli.py
import click
from rich.console import Console

console = Console()

@click.group()
@click.version_option()
@click.option("--config", "-c", type=click.Path(), help="Config file path")
@click.option("--verbose", "-v", is_flag=True, help="Verbose output")
@click.pass_context
def cli(ctx, config, verbose):
    """ChronoScribe - Transform handwritten documents into searchable archives."""
    ctx.ensure_object(dict)
    ctx.obj["config_path"] = config
    ctx.obj["verbose"] = verbose
    ctx.obj["console"] = console


# Register commands
from chronoscribe.commands import init, watch, process, search, clarify, timeline, stats

cli.add_command(init.init)
cli.add_command(watch.watch)
cli.add_command(process.process)
cli.add_command(search.search)
cli.add_command(clarify.clarify)
cli.add_command(timeline.timeline)
cli.add_command(stats.stats)
```

### Commands

#### init

```python
# src/chronoscribe/commands/init.py
import click
from rich.console import Console
from rich.panel import Panel
from pathlib import Path

@click.command()
@click.option("--path", "-p", default="~/ChronoScribe", help="Installation path")
@click.pass_context
def init(ctx, path):
    """Initialize ChronoScribe directory structure."""
    console = ctx.obj["console"]
    base_path = Path(path).expanduser()

    console.print(f"\n[bold]Initializing ChronoScribe[/bold] at {base_path}\n")

    # Create directories
    directories = [
        "inbox",
        "processing",
        "archive",
        "clarifications",
        "data",
        "logs",
        "exports",
        "config",
        "config/prompts",
    ]

    for dir_name in directories:
        dir_path = base_path / dir_name
        dir_path.mkdir(parents=True, exist_ok=True)
        console.print(f"  [green]✓[/green] Created {dir_name}/")

    # Create default config
    config_path = base_path / "config" / "config.yaml"
    if not config_path.exists():
        create_default_config(config_path)
        console.print(f"  [green]✓[/green] Created config/config.yaml")

    # Create .env template
    env_path = base_path / "config" / ".env"
    if not env_path.exists():
        create_env_template(env_path)
        console.print(f"  [green]✓[/green] Created config/.env template")

    # Initialize database
    db_path = base_path / "data" / "chronoscribe.db"
    initialize_database(db_path)
    console.print(f"  [green]✓[/green] Initialized database")

    console.print(Panel(
        f"""
[bold green]ChronoScribe initialized successfully![/bold green]

[bold]Next steps:[/bold]
1. Edit [cyan]{base_path}/config/.env[/cyan] with your API keys
2. Run [cyan]chronoscribe watch[/cyan] to start monitoring
3. Drop documents in [cyan]{base_path}/inbox/[/cyan]

[dim]Run 'chronoscribe --help' for all commands[/dim]
""".strip(),
        title="Setup Complete",
        border_style="green",
    ))
```

#### watch

```python
# src/chronoscribe/commands/watch.py
import click
import asyncio
from rich.console import Console
from rich.live import Live
from rich.table import Table

@click.command()
@click.option("--daemon", "-d", is_flag=True, help="Run in background")
@click.pass_context
def watch(ctx, daemon):
    """Start watching the inbox folder for new documents."""
    console = ctx.obj["console"]

    if daemon:
        console.print("[yellow]Daemon mode not yet implemented[/yellow]")
        return

    console.print("\n[bold]Starting ChronoScribe watcher...[/bold]\n")

    # Display status
    console.print(f"  Inbox:      ~/ChronoScribe/inbox/")
    console.print(f"  Archive:    ~/ChronoScribe/archive/")
    console.print(f"  Press [bold]Ctrl+C[/bold] to stop\n")

    try:
        asyncio.run(run_watcher(console))
    except KeyboardInterrupt:
        console.print("\n[yellow]Watcher stopped[/yellow]")


async def run_watcher(console: Console):
    """Main watcher loop."""
    from chronoscribe.core.watcher import FolderWatcher
    from chronoscribe.core.pipeline import Pipeline

    watcher = FolderWatcher(get_config())
    pipeline = Pipeline(get_config())

    await watcher.start()

    # Status display
    with Live(generate_status_table(), refresh_per_second=1, console=console) as live:
        while True:
            await asyncio.sleep(1)
            live.update(generate_status_table())


def generate_status_table() -> Table:
    """Generate status table for live display."""
    table = Table(title="Watcher Status")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", style="green")

    stats = get_current_stats()
    table.add_row("Documents processed", str(stats.get("processed", 0)))
    table.add_row("Pending in queue", str(stats.get("pending", 0)))
    table.add_row("Clarifications waiting", str(stats.get("clarifications", 0)))
    table.add_row("Uptime", stats.get("uptime", "0:00:00"))

    return table
```

#### process

```python
# src/chronoscribe/commands/process.py
import click
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn

@click.command()
@click.argument("file_path", type=click.Path(exists=True))
@click.option("--output", "-o", type=click.Path(), help="Output directory")
@click.pass_context
def process(ctx, file_path, output):
    """Process a single document file."""
    console = ctx.obj["console"]
    path = Path(file_path)

    console.print(f"\n[bold]Processing:[/bold] {path.name}\n")

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        # Preprocessing
        task = progress.add_task("Preprocessing image...", total=None)
        result = run_preprocessing(path)
        progress.update(task, completed=True)

        # Transcription
        task = progress.add_task("Transcribing...", total=None)
        transcription = run_transcription(result.normalized_path)
        progress.update(task, completed=True)

        # Analysis
        task = progress.add_task("Analyzing content...", total=None)
        analysis = run_analysis(transcription)
        progress.update(task, completed=True)

        # Save
        task = progress.add_task("Saving to archive...", total=None)
        doc = save_document(result, transcription, analysis)
        progress.update(task, completed=True)

    # Display results
    display_processing_result(console, doc, transcription, analysis)
```

#### search

```python
# src/chronoscribe/commands/search.py
import click
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.markdown import Markdown

@click.command()
@click.argument("query")
@click.option("--type", "-t", help="Filter by document type")
@click.option("--from", "date_from", help="Filter from date (YYYY-MM-DD)")
@click.option("--to", "date_to", help="Filter to date (YYYY-MM-DD)")
@click.option("--limit", "-n", default=10, help="Number of results")
@click.option("--full", "-f", is_flag=True, help="Show full transcriptions")
@click.pass_context
def search(ctx, query, type, date_from, date_to, limit, full):
    """Search across all documents."""
    console = ctx.obj["console"]

    filters = {}
    if type:
        filters["type"] = type
    if date_from:
        filters["date_from"] = date_from
    if date_to:
        filters["date_to"] = date_to

    results = run_search(query, filters, limit)

    if not results:
        console.print(f"\n[yellow]No results found for:[/yellow] {query}\n")
        return

    console.print(f"\n[bold]Found {len(results)} results for:[/bold] {query}\n")

    for i, result in enumerate(results, 1):
        doc = result.document
        date_str = doc.date_value.isoformat() if doc.date_value else "Undated"

        console.print(Panel(
            f"""
[bold]{doc.original_filename}[/bold]
[dim]{date_str} | {doc.document_type}[/dim]

{result.snippet}

[dim]Path: {doc.archive_path}[/dim]
""".strip(),
            title=f"Result {i}",
            border_style="blue",
        ))

        if full:
            transcription = load_transcription(doc.archive_path)
            console.print(Markdown(transcription))
            console.print()
```

#### clarify

```python
# src/chronoscribe/commands/clarify.py
import click
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt

@click.command()
@click.option("--document", "-d", help="Filter by document ID")
@click.option("--critical", "-c", is_flag=True, help="Show only critical")
@click.option("--count", is_flag=True, help="Show count only")
@click.pass_context
def clarify(ctx, document, critical, count):
    """Review and answer clarification questions."""
    console = ctx.obj["console"]

    pending = get_pending_clarifications(document_id=document)

    if critical:
        pending = [c for c in pending if c.is_critical]

    if count:
        console.print(f"\n[bold]{len(pending)}[/bold] pending clarifications\n")
        return

    if not pending:
        console.print("\n[green]No pending clarifications![/green]\n")
        return

    console.print(f"\n[bold]Found {len(pending)} pending clarifications[/bold]\n")

    for i, clarification in enumerate(pending, 1):
        display_clarification(console, clarification, i, len(pending))

        # Get answer
        answer = prompt_for_answer(console, clarification)

        if answer == "skip":
            continue
        elif answer == "quit":
            break

        # Submit answer
        submit_answer(clarification.id, answer)
        console.print("[green]Answer recorded![/green]\n")
```

#### timeline

```python
# src/chronoscribe/commands/timeline.py
import click
from rich.console import Console
from rich.tree import Tree

@click.command()
@click.option("--year", "-y", type=int, help="Show specific year")
@click.option("--month", "-m", type=int, help="Show specific month")
@click.option("--undated", "-u", is_flag=True, help="Show undated documents")
@click.pass_context
def timeline(ctx, year, month, undated):
    """View documents organized by date."""
    console = ctx.obj["console"]

    if undated:
        docs = get_undated_documents()
        display_undated_list(console, docs)
        return

    if year and month:
        docs = get_documents_for_month(year, month)
        display_month_view(console, year, month, docs)
    elif year:
        docs = get_documents_for_year(year)
        display_year_view(console, year, docs)
    else:
        summary = get_timeline_summary()
        display_timeline_tree(console, summary)


def display_timeline_tree(console: Console, summary: dict):
    """Display timeline as a tree."""
    tree = Tree("[bold]Document Timeline[/bold]")

    for year, months in sorted(summary.items(), reverse=True):
        year_branch = tree.add(f"[cyan]{year}[/cyan] ({sum(months.values())} docs)")

        for month, count in sorted(months.items()):
            month_name = get_month_name(month)
            year_branch.add(f"{month_name}: {count} documents")

    console.print(tree)
```

#### stats

```python
# src/chronoscribe/commands/stats.py
import click
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

@click.command()
@click.option("--usage", "-u", is_flag=True, help="Show API usage")
@click.pass_context
def stats(ctx, usage):
    """Show statistics and usage information."""
    console = ctx.obj["console"]

    stats = get_statistics()

    # Overview panel
    console.print(Panel(
        f"""
[bold]Total Documents:[/bold] {stats['total_documents']}
[bold]Pending Clarifications:[/bold] {stats['pending_clarifications']}
[bold]Storage Used:[/bold] {format_size(stats['storage_used'])}
""".strip(),
        title="Overview",
        border_style="green",
    ))

    # By type table
    table = Table(title="Documents by Type")
    table.add_column("Type", style="cyan")
    table.add_column("Count", justify="right")

    for doc_type, count in stats["by_type"].items():
        table.add_row(doc_type, str(count))

    console.print(table)

    if usage:
        display_api_usage(console)


def display_api_usage(console: Console):
    """Display API usage statistics."""
    usage = get_api_usage_summary()

    table = Table(title="API Usage (This Month)")
    table.add_column("Provider", style="cyan")
    table.add_column("Calls", justify="right")
    table.add_column("Success Rate", justify="right")
    table.add_column("Avg Time", justify="right")
    table.add_column("Cost", justify="right")

    for provider, data in usage.items():
        success_rate = f"{data['successful_calls'] / data['total_calls'] * 100:.1f}%"
        table.add_row(
            provider,
            str(data["total_calls"]),
            success_rate,
            f"{data['avg_response_time_ms']:.0f}ms",
            f"${data['total_cost']:.2f}" if data['total_cost'] else "Free",
        )

    console.print(table)
```

### Entry Point

```python
# src/chronoscribe/__main__.py
from chronoscribe.cli import cli

if __name__ == "__main__":
    cli()
```

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | General error |
| 2 | Invalid arguments |
| 3 | Configuration error |
| 4 | File not found |
| 5 | Permission denied |
| 6 | Network error |
| 7 | API error |

## Testing Strategy

### Unit Tests

```python
from click.testing import CliRunner

def test_init_creates_directories(tmp_path):
    runner = CliRunner()
    result = runner.invoke(cli, ["init", "--path", str(tmp_path)])

    assert result.exit_code == 0
    assert (tmp_path / "inbox").exists()
    assert (tmp_path / "archive").exists()

def test_search_returns_results(mock_db):
    runner = CliRunner()
    result = runner.invoke(cli, ["search", "solar heater"])

    assert result.exit_code == 0
    assert "Found" in result.output

def test_stats_displays_overview():
    runner = CliRunner()
    result = runner.invoke(cli, ["stats"])

    assert result.exit_code == 0
    assert "Total Documents" in result.output
```

## Acceptance Criteria

- [ ] All commands have --help
- [ ] `init` creates directory structure
- [ ] `watch` monitors inbox
- [ ] `process` handles single files
- [ ] `search` returns relevant results
- [ ] `clarify` interactive review works
- [ ] `timeline` displays chronologically
- [ ] `stats` shows usage information
- [ ] Progress bars for long operations
- [ ] Clear error messages
- [ ] Exit codes follow conventions
