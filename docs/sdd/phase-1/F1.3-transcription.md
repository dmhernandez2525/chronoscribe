# F1.3 - Multi-Provider Transcription

## Overview

| Attribute | Value |
|-----------|-------|
| Feature ID | F1.3 |
| Phase | 1 (MVP) |
| Priority | P0 |
| Status | Planned |
| Module | `chronoscribe.services.transcription` |

## Description

AI-powered text transcription using multiple providers with intelligent fallback. Leverages free tiers from Azure (5K/month) and Google (1K/month), with OpenAI and local Ollama as fallbacks. The system tracks confidence scores per text block and logs API usage for cost management.

## Requirements

### Functional Requirements

1. **FR1.3.1** - Support Azure Computer Vision as primary provider
2. **FR1.3.2** - Support Google Cloud Vision as secondary provider
3. **FR1.3.3** - Support OpenAI GPT-4o Vision for difficult content
4. **FR1.3.4** - Support Ollama/LLaVA for fully local processing
5. **FR1.3.5** - Automatic fallback on failure or quota exhaustion
6. **FR1.3.6** - Track confidence scores per text block
7. **FR1.3.7** - Log API usage for cost tracking
8. **FR1.3.8** - Handle both typed and handwritten text

### Non-Functional Requirements

1. **NFR1.3.1** - Typed text accuracy: 98%+
2. **NFR1.3.2** - Handwritten text accuracy: 85%+
3. **NFR1.3.3** - Transcription time: < 20 seconds per page
4. **NFR1.3.4** - Graceful degradation when all providers fail

## Technical Design

### Dependencies

```python
# Optional dependencies based on provider
azure-cognitiveservices-vision-computervision>=0.9.0
azure-core>=1.29.0
google-cloud-vision>=3.5.0
openai>=1.6.0
ollama>=0.1.0
httpx>=0.25.0  # Async HTTP client
```

### Module Structure

```
src/chronoscribe/services/transcription/
├── __init__.py          # Public exports
├── base.py              # Abstract base class and types
├── azure.py             # Azure Computer Vision provider
├── google.py            # Google Cloud Vision provider
├── openai.py            # OpenAI GPT-4o provider
├── ollama.py            # Local Ollama/LLaVA provider
├── manager.py           # Provider selection and fallback
└── usage.py             # Usage tracking
```

### Type Definitions

```python
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from datetime import datetime

class ProviderName(Enum):
    AZURE = "azure"
    GOOGLE = "google"
    OPENAI = "openai"
    OLLAMA = "ollama"

@dataclass
class BoundingBox:
    """Coordinates of a text region."""
    x: int
    y: int
    width: int
    height: int

@dataclass
class TextBlock:
    """A block of transcribed text with metadata."""
    text: str
    confidence: float
    bounding_box: BoundingBox | None = None
    block_type: str = "paragraph"  # word, line, paragraph
    language: str | None = None

@dataclass
class TranscriptionResult:
    """Complete transcription result."""
    text: str
    blocks: list[TextBlock]
    provider: ProviderName
    confidence: float  # Overall confidence
    language: str
    processing_time_ms: int
    word_count: int
    low_confidence_blocks: list[TextBlock] = field(default_factory=list)
    raw_response: dict | None = None

class TranscriptionError(Exception):
    """Error during transcription."""
    def __init__(self, message: str, provider: ProviderName | None = None):
        self.provider = provider
        super().__init__(message)
```

### Abstract Base Class

```python
from abc import ABC, abstractmethod

class TranscriptionProvider(ABC):
    """Abstract base class for transcription providers."""

    name: ProviderName

    @abstractmethod
    async def transcribe(self, image_path: Path) -> TranscriptionResult:
        """
        Transcribe text from an image.

        Args:
            image_path: Path to the preprocessed image

        Returns:
            TranscriptionResult with text and confidence scores

        Raises:
            TranscriptionError: If transcription fails
        """
        pass

    @abstractmethod
    async def is_available(self) -> bool:
        """Check if the provider is configured and has quota."""
        pass

    @abstractmethod
    def get_remaining_quota(self) -> int | None:
        """Get remaining free tier quota, or None if unlimited/unknown."""
        pass
```

### Provider Manager

```python
@dataclass
class ProviderConfig:
    name: ProviderName
    enabled: bool
    priority: int
    free_tier_limit: int | None
    confidence_threshold: float

class TranscriptionManager:
    """
    Manages transcription providers with intelligent fallback.

    Selects providers based on:
    1. Priority order from configuration
    2. Remaining free tier quota
    3. Provider availability
    """

    def __init__(
        self,
        providers: list[TranscriptionProvider],
        config: list[ProviderConfig],
        usage_tracker: UsageTracker,
    ):
        self.providers = {p.name: p for p in providers}
        self.config = sorted(config, key=lambda c: c.priority)
        self.usage_tracker = usage_tracker

    async def transcribe(
        self,
        image_path: Path,
        preferred_provider: ProviderName | None = None,
    ) -> TranscriptionResult:
        """
        Transcribe an image using the best available provider.

        Tries providers in priority order, falling back on failure.
        """
        errors = []

        for provider_config in self._get_provider_order(preferred_provider):
            provider = self.providers.get(provider_config.name)
            if not provider:
                continue

            if not await provider.is_available():
                continue

            try:
                result = await provider.transcribe(image_path)

                # Track usage
                await self.usage_tracker.record(
                    provider=provider_config.name,
                    success=True,
                )

                # Flag low confidence blocks
                result.low_confidence_blocks = [
                    b for b in result.blocks
                    if b.confidence < provider_config.confidence_threshold
                ]

                return result

            except TranscriptionError as e:
                errors.append(e)
                await self.usage_tracker.record(
                    provider=provider_config.name,
                    success=False,
                    error=str(e),
                )
                continue

        raise TranscriptionError(
            f"All providers failed: {[str(e) for e in errors]}"
        )
```

### Azure Provider Implementation

```python
from azure.cognitiveservices.vision.computervision import ComputerVisionClient
from azure.cognitiveservices.vision.computervision.models import OperationStatusCodes
from azure.core.credentials import AzureKeyCredential

class AzureTranscriber(TranscriptionProvider):
    """Azure Computer Vision OCR provider."""

    name = ProviderName.AZURE

    def __init__(self, endpoint: str, api_key: str):
        self.endpoint = endpoint
        self.client = ComputerVisionClient(
            endpoint=endpoint,
            credential=AzureKeyCredential(api_key),
        )

    async def transcribe(self, image_path: Path) -> TranscriptionResult:
        start_time = datetime.now()

        with open(image_path, "rb") as f:
            # Start async read operation
            read_response = self.client.read_in_stream(f, raw=True)

        # Get operation ID from response headers
        operation_location = read_response.headers["Operation-Location"]
        operation_id = operation_location.split("/")[-1]

        # Poll for result
        while True:
            result = self.client.get_read_result(operation_id)
            if result.status not in [
                OperationStatusCodes.running,
                OperationStatusCodes.not_started,
            ]:
                break
            await asyncio.sleep(0.5)

        if result.status != OperationStatusCodes.succeeded:
            raise TranscriptionError(
                f"Azure OCR failed with status: {result.status}",
                provider=self.name,
            )

        # Parse results
        blocks = []
        full_text_parts = []

        for read_result in result.analyze_result.read_results:
            for line in read_result.lines:
                blocks.append(TextBlock(
                    text=line.text,
                    confidence=self._get_line_confidence(line),
                    bounding_box=self._parse_bbox(line.bounding_box),
                    block_type="line",
                ))
                full_text_parts.append(line.text)

        processing_time = int((datetime.now() - start_time).total_seconds() * 1000)
        full_text = "\n".join(full_text_parts)

        return TranscriptionResult(
            text=full_text,
            blocks=blocks,
            provider=self.name,
            confidence=self._calculate_overall_confidence(blocks),
            language=result.analyze_result.read_results[0].language if result.analyze_result.read_results else "en",
            processing_time_ms=processing_time,
            word_count=len(full_text.split()),
        )
```

### Configuration

```yaml
transcription:
  providers:
    - name: azure
      enabled: true
      priority: 1
      free_tier_limit: 5000
      confidence_threshold: 0.7

    - name: google
      enabled: true
      priority: 2
      free_tier_limit: 1000
      confidence_threshold: 0.7

    - name: openai
      enabled: true
      priority: 3
      cost_per_image: 0.01
      confidence_threshold: 0.8

    - name: ollama
      enabled: false
      priority: 4
      model: llava
      endpoint: http://localhost:11434
      confidence_threshold: 0.6

  fallback:
    retry_on_failure: true
    max_retries: 3
```

### Usage Tracking

```python
@dataclass
class UsageRecord:
    provider: ProviderName
    timestamp: datetime
    document_id: str | None
    success: bool
    tokens_used: int | None
    cost_usd: float | None
    response_time_ms: int
    error_message: str | None

class UsageTracker:
    """Tracks API usage for cost management."""

    async def record(
        self,
        provider: ProviderName,
        success: bool,
        document_id: str | None = None,
        tokens_used: int | None = None,
        cost_usd: float | None = None,
        response_time_ms: int | None = None,
        error: str | None = None,
    ) -> None:
        """Record an API usage event."""
        ...

    async def get_monthly_usage(self, provider: ProviderName) -> int:
        """Get total usage for current month."""
        ...

    async def get_remaining_free_tier(self, provider: ProviderName) -> int | None:
        """Get remaining free tier quota for provider."""
        ...
```

## API

### Public Interface

```python
# Main entry point
async def transcribe(
    image_path: Path,
    preferred_provider: ProviderName | None = None,
) -> TranscriptionResult:
    """
    Transcribe an image using the best available provider.

    Args:
        image_path: Path to a preprocessed image
        preferred_provider: Optional preferred provider to try first

    Returns:
        TranscriptionResult with text and metadata

    Raises:
        TranscriptionError: If all providers fail
    """
```

## Testing Strategy

### Unit Tests

```python
# tests/unit/services/transcription/test_azure.py

@pytest.mark.asyncio
async def test_azure_transcriber_parses_response(mock_azure_client):
    transcriber = AzureTranscriber(endpoint="test", api_key="test")

    mock_azure_client.read_in_stream.return_value = mock_read_response
    mock_azure_client.get_read_result.return_value = mock_success_result

    result = await transcriber.transcribe(Path("test.png"))

    assert result.text == "Expected text"
    assert result.provider == ProviderName.AZURE
    assert len(result.blocks) > 0

@pytest.mark.asyncio
async def test_manager_falls_back_on_azure_failure():
    azure_provider = Mock()
    azure_provider.is_available.return_value = True
    azure_provider.transcribe.side_effect = TranscriptionError("API error")

    google_provider = Mock()
    google_provider.is_available.return_value = True
    google_provider.transcribe.return_value = mock_result

    manager = TranscriptionManager(
        providers=[azure_provider, google_provider],
        config=[azure_config, google_config],
    )

    result = await manager.transcribe(Path("test.png"))

    assert result.provider == ProviderName.GOOGLE
```

### Integration Tests

```python
# tests/integration/test_transcription_integration.py

@pytest.mark.integration
@pytest.mark.asyncio
async def test_real_azure_transcription(sample_document):
    """Test with real Azure API (requires credentials)."""
    transcriber = AzureTranscriber(
        endpoint=os.environ["AZURE_VISION_ENDPOINT"],
        api_key=os.environ["AZURE_VISION_KEY"],
    )

    result = await transcriber.transcribe(sample_document)

    assert len(result.text) > 0
    assert result.confidence > 0.5
```

## Dependencies

### Upstream
- Image preprocessor (provides normalized images)
- Configuration (for provider settings)

### Downstream
- Analysis engine (receives transcription)
- Clarification manager (receives low-confidence blocks)
- Database (stores results)

## Implementation Notes

1. **Async HTTP**: Use httpx for async HTTP requests
2. **Retry Logic**: Implement exponential backoff for transient errors
3. **Rate Limiting**: Respect provider rate limits
4. **Caching**: Don't cache transcriptions (images may change)
5. **Logging**: Log all API calls at INFO level with timing

## Acceptance Criteria

- [ ] Azure Computer Vision integration works correctly
- [ ] Google Cloud Vision integration works correctly
- [ ] OpenAI GPT-4o integration works correctly
- [ ] Ollama/LLaVA integration works correctly
- [ ] Automatic fallback occurs on failure
- [ ] Automatic fallback occurs on quota exhaustion
- [ ] Confidence scores are extracted per text block
- [ ] Low-confidence blocks are flagged for review
- [ ] API usage is logged to database
- [ ] Typed text accuracy meets 98%+ target
- [ ] Handwritten text accuracy meets 85%+ target
