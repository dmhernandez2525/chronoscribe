# F1.6 - Date Detection & Timeline

## Overview

| Attribute | Value |
|-----------|-------|
| Feature ID | F1.6 |
| Phase | 1 (MVP) |
| Priority | P0 |
| Status | Planned |
| Module | `chronoscribe.services.timeline` |

## Description

Extract dates from documents using multiple strategies (explicit text, EXIF metadata, filename patterns, AI inference) and organize documents chronologically. This enables automatic timeline-based organization that no competitor offers.

## Requirements

### Functional Requirements

1. **FR1.6.1** - Parse explicit dates in document text (multiple formats)
2. **FR1.6.2** - Extract dates from EXIF metadata
3. **FR1.6.3** - Match filename patterns for dates
4. **FR1.6.4** - AI inference for context-based dates
5. **FR1.6.5** - Assign confidence scores to all extracted dates
6. **FR1.6.6** - Select primary date using priority rules
7. **FR1.6.7** - Handle undated documents gracefully

### Non-Functional Requirements

1. **NFR1.6.1** - Date extraction: < 2 seconds per document
2. **NFR1.6.2** - Accuracy: > 95% for explicit dates
3. **NFR1.6.3** - Support multiple date formats

## Technical Design

### Dependencies

```python
python-dateutil>=2.8.0    # Date parsing
dateparser>=1.2.0         # Natural language dates
```

### Module Structure

```
src/chronoscribe/services/
└── timeline.py           # Date extraction and timeline service
```

### Type Definitions

```python
from dataclasses import dataclass
from datetime import date
from enum import Enum
from typing import Literal

class DateSource(Enum):
    EXPLICIT = "explicit"      # Parsed from document text
    EXIF = "exif"              # From image EXIF metadata
    FILENAME = "filename"      # From filename pattern
    INFERRED = "inferred"      # AI-inferred from context

class DatePrecision(Enum):
    DAY = "day"           # Full date: 2019-03-15
    MONTH = "month"       # Month only: 2019-03
    YEAR = "year"         # Year only: 2019
    DECADE = "decade"     # Decade: 1990s
    APPROXIMATE = "approximate"  # Rough estimate

@dataclass
class ExtractedDate:
    """A date extracted from a document."""
    value: date
    source: DateSource
    precision: DatePrecision
    confidence: float
    context: str | None = None  # Surrounding text or metadata
    raw_text: str | None = None  # Original text that was parsed

@dataclass
class TimelineEntry:
    """A document's position on the timeline."""
    document_id: str
    primary_date: date | None
    primary_date_confidence: float | None
    primary_date_source: DateSource | None
    all_dates: list[ExtractedDate]
    is_undated: bool
```

### Date Patterns

```python
# Supported explicit date formats
DATE_PATTERNS = [
    # ISO format
    r"\b(\d{4})-(\d{1,2})-(\d{1,2})\b",           # 2019-03-15

    # US format
    r"\b(\d{1,2})/(\d{1,2})/(\d{4})\b",           # 03/15/2019
    r"\b(\d{1,2})/(\d{1,2})/(\d{2})\b",           # 03/15/19

    # European format
    r"\b(\d{1,2})\.(\d{1,2})\.(\d{4})\b",         # 15.03.2019

    # Written format
    r"\b(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+(\d{1,2})(?:st|nd|rd|th)?,?\s+(\d{4})\b",  # March 15, 2019

    # Abbreviated
    r"\b(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?\s+(\d{4})\b",  # 15 Mar 2019
]

# Filename patterns
FILENAME_PATTERNS = [
    r"(\d{4})-(\d{2})-(\d{2})",      # 2019-03-15
    r"(\d{4})(\d{2})(\d{2})",        # 20190315
    r"IMG_(\d{4})(\d{2})(\d{2})",    # IMG_20190315
    r"(\d{2})-(\d{2})-(\d{4})",      # 03-15-2019
]
```

### Implementation

```python
import re
from datetime import date, datetime
from dateutil import parser as dateutil_parser
import dateparser

class TimelineService:
    """
    Extracts dates from documents and manages timeline organization.
    """

    def __init__(self, anthropic_client: Anthropic | None = None):
        self.anthropic = anthropic_client

    async def extract_dates(
        self,
        text: str,
        exif_data: dict | None = None,
        filename: str | None = None,
    ) -> list[ExtractedDate]:
        """
        Extract all dates from available sources.

        Args:
            text: Document transcription text
            exif_data: EXIF metadata (if available)
            filename: Original filename

        Returns:
            List of extracted dates with confidence scores
        """
        dates = []

        # 1. Extract explicit dates from text
        dates.extend(self._extract_explicit_dates(text))

        # 2. Extract EXIF dates
        if exif_data:
            dates.extend(self._extract_exif_dates(exif_data))

        # 3. Extract filename dates
        if filename:
            dates.extend(self._extract_filename_dates(filename))

        # 4. AI inference for context clues
        if self.anthropic and not dates:
            inferred = await self._infer_dates(text)
            dates.extend(inferred)

        return dates

    def select_primary_date(
        self,
        dates: list[ExtractedDate],
    ) -> tuple[date | None, float | None, DateSource | None]:
        """
        Select the best date to use as the document's primary date.

        Priority order:
        1. Explicit date in header/title (high confidence)
        2. Explicit date anywhere (high confidence)
        3. EXIF date
        4. Filename date
        5. Inferred date

        Returns:
            Tuple of (date, confidence, source) or (None, None, None)
        """
        if not dates:
            return None, None, None

        # Sort by priority
        def priority_key(d: ExtractedDate) -> tuple:
            source_priority = {
                DateSource.EXPLICIT: 0,
                DateSource.EXIF: 1,
                DateSource.FILENAME: 2,
                DateSource.INFERRED: 3,
            }
            return (source_priority[d.source], -d.confidence)

        sorted_dates = sorted(dates, key=priority_key)
        best = sorted_dates[0]

        return best.value, best.confidence, best.source

    def _extract_explicit_dates(self, text: str) -> list[ExtractedDate]:
        """Extract dates explicitly written in the document."""
        dates = []

        # Try dateparser for natural language dates
        # Look at first few lines (likely header) with higher confidence
        lines = text.split("\n")
        header_lines = lines[:5]
        body_lines = lines[5:]

        # Header dates (higher confidence)
        for line in header_lines:
            parsed = dateparser.parse(
                line,
                settings={
                    "PREFER_DATES_FROM": "past",
                    "STRICT_PARSING": True,
                },
            )
            if parsed:
                dates.append(ExtractedDate(
                    value=parsed.date(),
                    source=DateSource.EXPLICIT,
                    precision=DatePrecision.DAY,
                    confidence=0.95,
                    context="Document header",
                    raw_text=line.strip(),
                ))

        # Body dates (lower confidence - might be references)
        for pattern in DATE_PATTERNS:
            for match in re.finditer(pattern, "\n".join(body_lines), re.IGNORECASE):
                try:
                    parsed = dateutil_parser.parse(match.group())
                    dates.append(ExtractedDate(
                        value=parsed.date(),
                        source=DateSource.EXPLICIT,
                        precision=DatePrecision.DAY,
                        confidence=0.8,
                        context="Document body",
                        raw_text=match.group(),
                    ))
                except (ValueError, TypeError):
                    continue

        return dates

    def _extract_exif_dates(self, exif_data: dict) -> list[ExtractedDate]:
        """Extract dates from EXIF metadata."""
        dates = []

        # Common EXIF date fields
        date_fields = [
            ("DateTimeOriginal", 0.9),
            ("DateTime", 0.85),
            ("DateTimeDigitized", 0.85),
            ("CreateDate", 0.85),
        ]

        for field, confidence in date_fields:
            if field in exif_data:
                try:
                    # EXIF format: "2019:03:15 10:30:00"
                    value = exif_data[field]
                    if isinstance(value, str):
                        parsed = datetime.strptime(
                            value.split()[0],
                            "%Y:%m:%d",
                        )
                        dates.append(ExtractedDate(
                            value=parsed.date(),
                            source=DateSource.EXIF,
                            precision=DatePrecision.DAY,
                            confidence=confidence,
                            context=f"EXIF {field}",
                            raw_text=value,
                        ))
                except (ValueError, TypeError):
                    continue

        return dates

    def _extract_filename_dates(self, filename: str) -> list[ExtractedDate]:
        """Extract dates from filename patterns."""
        dates = []

        for pattern in FILENAME_PATTERNS:
            match = re.search(pattern, filename)
            if match:
                groups = match.groups()
                try:
                    # Determine order based on pattern
                    if len(groups[0]) == 4:  # Year first
                        year, month, day = int(groups[0]), int(groups[1]), int(groups[2])
                    else:  # Month/day first
                        month, day, year = int(groups[0]), int(groups[1]), int(groups[2])

                    if year < 100:  # Two-digit year
                        year += 2000 if year < 50 else 1900

                    parsed_date = date(year, month, day)

                    dates.append(ExtractedDate(
                        value=parsed_date,
                        source=DateSource.FILENAME,
                        precision=DatePrecision.DAY,
                        confidence=0.75,
                        context=f"Filename pattern",
                        raw_text=match.group(),
                    ))
                    break  # Use first match only
                except (ValueError, TypeError):
                    continue

        return dates

    async def _infer_dates(self, text: str) -> list[ExtractedDate]:
        """Use AI to infer dates from context clues."""
        if not self.anthropic:
            return []

        prompt = f"""Analyze this document and estimate when it might have been written.
Look for contextual clues like:
- References to events, seasons, or time periods
- Technology or products mentioned
- Writing style or terminology
- Any temporal context

Document text:
{text[:2000]}  # Limit for cost

If you can estimate a date or date range, respond with JSON:
{{
    "estimated_date": "YYYY-MM-DD",
    "precision": "day|month|year|decade",
    "confidence": 0.0-1.0,
    "reasoning": "Brief explanation"
}}

If you cannot estimate a date, respond with:
{{"estimated_date": null}}
"""

        try:
            message = self.anthropic.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=256,
                messages=[{"role": "user", "content": prompt}],
            )

            response = json.loads(message.content[0].text)

            if response.get("estimated_date"):
                parsed = datetime.strptime(
                    response["estimated_date"],
                    "%Y-%m-%d",
                ).date()

                return [ExtractedDate(
                    value=parsed,
                    source=DateSource.INFERRED,
                    precision=DatePrecision(response.get("precision", "year")),
                    confidence=min(response.get("confidence", 0.5), 0.7),  # Cap at 0.7
                    context=response.get("reasoning"),
                    raw_text=None,
                )]
        except Exception:
            pass

        return []
```

### Timeline View

```python
@dataclass
class TimelineView:
    """A view of documents organized by time period."""
    period: str  # e.g., "2019", "2019-03"
    documents: list[TimelineEntry]
    count: int

class TimelineFormatter:
    """Formats timeline data for display."""

    def format_by_year(
        self,
        entries: list[TimelineEntry],
    ) -> list[TimelineView]:
        """Group entries by year."""
        by_year = defaultdict(list)

        for entry in entries:
            if entry.primary_date:
                year = str(entry.primary_date.year)
            else:
                year = "Undated"
            by_year[year].append(entry)

        return [
            TimelineView(
                period=year,
                documents=docs,
                count=len(docs),
            )
            for year, docs in sorted(by_year.items(), reverse=True)
        ]

    def format_by_month(
        self,
        entries: list[TimelineEntry],
        year: int,
    ) -> list[TimelineView]:
        """Group entries by month within a year."""
        by_month = defaultdict(list)

        for entry in entries:
            if entry.primary_date and entry.primary_date.year == year:
                month = entry.primary_date.strftime("%Y-%m")
                by_month[month].append(entry)

        return [
            TimelineView(
                period=month,
                documents=docs,
                count=len(docs),
            )
            for month, docs in sorted(by_month.items(), reverse=True)
        ]
```

## CLI Commands

```bash
# View timeline summary
chronoscribe timeline

# View specific year
chronoscribe timeline --year 2019

# View specific month
chronoscribe timeline --year 2019 --month 3

# List undated documents
chronoscribe timeline --undated

# Re-extract dates for document
chronoscribe redate <document-id>
```

## Testing Strategy

### Unit Tests

```python
def test_extract_explicit_date_iso():
    service = TimelineService()
    dates = service._extract_explicit_dates("Meeting notes for 2019-03-15")

    assert len(dates) == 1
    assert dates[0].value == date(2019, 3, 15)
    assert dates[0].source == DateSource.EXPLICIT

def test_extract_explicit_date_written():
    service = TimelineService()
    dates = service._extract_explicit_dates("March 15, 2019 - Project kickoff")

    assert len(dates) >= 1
    assert any(d.value == date(2019, 3, 15) for d in dates)

def test_extract_filename_date():
    service = TimelineService()
    dates = service._extract_filename_dates("IMG_20190315_123456.jpg")

    assert len(dates) == 1
    assert dates[0].value == date(2019, 3, 15)
    assert dates[0].source == DateSource.FILENAME

def test_select_primary_prefers_explicit():
    service = TimelineService()
    dates = [
        ExtractedDate(value=date(2019, 3, 15), source=DateSource.EXPLICIT, confidence=0.9, ...),
        ExtractedDate(value=date(2019, 3, 10), source=DateSource.EXIF, confidence=0.9, ...),
    ]

    primary, _, source = service.select_primary_date(dates)

    assert primary == date(2019, 3, 15)
    assert source == DateSource.EXPLICIT
```

## Acceptance Criteria

- [ ] Explicit dates parsed in multiple formats
- [ ] EXIF dates extracted correctly
- [ ] Filename patterns matched
- [ ] AI inference works for undated documents
- [ ] Confidence scores assigned appropriately
- [ ] Primary date selected using priority rules
- [ ] Undated documents handled gracefully
- [ ] Timeline CLI displays correctly
- [ ] Date extraction < 2 seconds
